question,response,time_sec,route,relevant,supported,useful
¿Cuántas horas debe trabajar cada estudiante por sprint?,"Según la información proporcionada, cada estudiante debe dedicar **36 horas de trabajo efectivo** a la realización del proyecto por sprint.

Este cálculo se obtiene de la siguiente manera:

1.  La carga de trabajo semanal para un alumno es de 20 horas.
2.  Como los sprints son de dos semanas, la carga total por sprint es de 40 horas por persona (20 horas/semana * 2 semanas).
3.  A estas 40 horas se les descuentan 4 horas dedicadas a las reuniones de Scrum (*Sprint Planning*, *Product Backlog Refinement*, *Sprint Review* y *Sprint Retrospective*).
4.  Por lo tanto, el trabajo efectivo final es de 36 horas por sprint (40 - 4 = 36).",30.41,VECTOR,True,True,True
¿Cómo debo nombrar al apk?,"Basándome en el contexto proporcionado, no puedo responder a tu pregunta. La información disponible trata sobre la especificación de casos de uso para una aplicación de seguros, el uso de `EntityManager` en Jakarta Persistence y ejemplos de definición de actores y alcance en el diseño de software.

No hay ninguna mención sobre cómo nombrar un archivo APK.",26.04,VECTOR,True,True,True
¿Cuál es la diferencia entre requisitos funcionales y no funcionales? Explícamelo con una tabla comparativa.,"Claro, aquí tienes la explicación sobre la diferencia entre requisitos funcionales y no funcionales, presentada en una tabla comparativa y basada en la información del contexto.

La principal diferencia es que los **requisitos funcionales** describen **lo que** el sistema debe hacer (sus funciones y servicios), mientras que los **requisitos no funcionales** describen **cómo** debe hacerlo, estableciendo cualidades, propiedades y restricciones sobre el sistema.

Aquí tienes una tabla comparativa para ilustrarlo mejor:

| Característica | Requisitos Funcionales (RF) | Requisitos No Funcionales (RNF) |
| :--- | :--- | :--- |
| **Definición** | Describen las funciones, servicios o comportamientos que el sistema debe proveer. Se centran en las tareas específicas que el usuario podrá realizar. | Describen las cualidades del sistema y las restricciones bajo las cuales debe operar. A menudo se refieren al sistema en su conjunto. |
| **Enfoque** | El **""qué""** hace el sistema. | El **""cómo""** lo hace el sistema (con qué calidad, rendimiento, seguridad, etc.). |
| **Ejemplos** | Basados en la **Adecuación Funcional (ISO 25010)** del contexto: <br><ul><li>**Completitud Funcional:** ""El sistema debe cubrir todas las tareas especificadas para la gestión de inventario, incluyendo añadir, modificar y eliminar productos.""</li><li>**Corrección Funcional:** ""El sistema debe calcular el precio final de una compra, incluyendo impuestos y descuentos, con el grado de precisión requerido.""</li><li>**Pertinencia Funcional:** ""El sistema debe guiar al usuario a través de los pasos necesarios para completar una devolución, sin mostrarle opciones irrelevantes.""</li></ul> | Basados en la **Eficacia en el Rendimiento** y otros tipos de pruebas del contexto: <br><ul><li>**Rendimiento (Tiempo de respuesta):** ""El tiempo de respuesta al realizar una búsqueda de producto no debe superar los 2 segundos.""</li><li>**Resistencia (Estrés):** ""El sistema debe poder soportar hasta 1000 usuarios concurrentes sin fallar.""</li><li>**Fiabilidad:** ""El sistema debe tener una tasa de fallos inferior al 1% durante las operaciones normales.""</li><li>**Recuperación:** ""En caso de un fallo grave, el sistema debe ser capaz de recuperarse y volver a estar operativo en menos de 15 minutos.""</li></ul> |
| **Verificación** | Se verifican mediante pruebas que comprueban si una función se ejecuta correctamente o no (pasa/no pasa). | Se miden y evalúan mediante pruebas específicas (rendimiento, estrés, etc.) para comprobar si se cumple un determinado umbral o métrica.",45.44,VECTOR,False,False,False
¿Cómo se organizan las pruebas unitarias?,"Según la información del contexto, la organización de las pruebas unitarias se basa en los siguientes puntos clave:

*   **Responsabilidad del equipo**: Es responsabilidad de cada grupo de desarrollo seguir los criterios indicados para la organización del código de las pruebas.
*   **Identificación clara**: La organización debe ser tal que sea **fácilmente identificable qué caso de prueba implementa cada test**.
*   **Vinculación con Historias de Usuario**: Se exige que cada historia de usuario tenga, como mínimo, una prueba unitaria o de integración codificada y ejecutada.
*   **Aislamiento**: Las pruebas unitarias se centran en verificar el funcionamiento **aislado** de piezas de software, como métodos o clases individuales.
*   **Planificación formal**: Las pruebas unitarias se enmarcan dentro de un **Plan de Pruebas Unitarias**, que a su vez deriva del diseño detallado del software.
*   **Herramientas**: Se implementan utilizando el framework **JUnit**. En caso de que existan dependencias con otras clases, se pueden usar librerías como **Mockito** y/o **Robolectric** para simularlas y mantener el aislamiento.",34.2,VECTOR,True,True,True
¿Cómo se puede probar un método de una clase que ejecuta en su propio thread sin usar Thread.Sleep?,"Basándome en el contexto proporcionado, no hay una respuesta directa a cómo probar un método que se ejecuta en su propio hilo sin usar `Thread.sleep()`. El contexto describe los tipos de pruebas (unitarias, integración, UI) y las herramientas que se usan (JUnit, Mockito, Robolectric, Espresso), pero no entra en detalles sobre técnicas específicas para manejar código asíncrono o concurrente.

Sin embargo, como TutorIS, experto en Ingeniería de Software, puedo explicarte las técnicas estándar y recomendadas para esta situación, especialmente relevantes en el entorno de Android que se menciona en los documentos.

El uso de `Thread.sleep()` en las pruebas es una mala práctica porque las hace:
*   **Poco fiables (flaky):** La prueba puede fallar si el hilo tarda más de lo esperado en terminar.
*   **Lentas:** La prueba siempre esperará el tiempo máximo definido, incluso si el hilo termina mucho antes.

Para evitar esto, se utilizan mecanismos de sincronización. Aquí tienes las dos soluciones más comunes:

### 1. En Pruebas Unitarias o de Integración (Java/Kotlin General)

La solución más común es usar un `CountDownLatch`. Es una herramienta de sincronización que permite a uno o más hilos esperar hasta que un conjunto de operaciones que se ejecutan en otros hilos se completen.

**¿Cómo funciona?**
1.  En tu prueba, creas un `CountDownLatch` inicializado con un contador de 1.
2.  Pasas una referencia de este `latch` (o un callback que lo use) al objeto que estás probando.
3.  El método de prueba llama a `latch.await()`. Esto bloqueará el hilo de la prueba hasta que el contador del latch llegue a cero.
4.  Cuando el hilo de trabajo termina su tarea, llama a `latch.countDown()`, lo que decrementa el contador a cero.
5.  El hilo de la prueba se desbloquea y puede continuar para realizar las aserciones (verificaciones).

**Ejemplo conceptual:**

```java
@Test
public void testMetodoAsincrono() throws InterruptedException {
    //",40.13,VECTOR,True,False,True
"En pruebas con Espresso ¿cómo se puede acceder a un SearchView que se encuentra dentro de un Toolbar, de los que usan el icono de lupa?","Basándome en el contexto proporcionado, no hay un ejemplo específico para acceder a un `SearchView` que se encuentra dentro de un `Toolbar`.

Sin embargo, podemos aplicar los principios generales de Espresso que sí se mencionan en el contexto para construir la solución. El flujo básico de Espresso es: **Selección de elemento -> Acción -> Comprobación**.

Para tu caso, el proceso sería el siguiente:

1.  **Hacer clic en el icono de la lupa para activar el `SearchView`**. El icono de la lupa es un elemento del menú de opciones. Generalmente, se le asigna un ID en el fichero XML del menú. Suponiendo que el ID es `R.id.action_search`, el código para hacer clic en él sería:

    ```java
    onView(withId(R.id.action_search)).perform(click());
    ```

2.  **Escribir en el campo de texto del `SearchView`**. Una vez que el `SearchView` está visible, puedes interactuar con él para escribir el texto de búsqueda. El campo de texto dentro de un `SearchView` de AndroidX suele tener un ID específico. Puedes seleccionarlo y escribir en él de la siguiente manera:

    ```java
    // El ID search_src_text es el que suele tener el EditText dentro de un SearchView de AppCompat
    onView(withId(androidx.appcompat.R.id.search_src_text)).perform(typeText(""mi búsqueda""), pressKey(KeyEvent.KEYCODE_ENTER));
    ```

Este enfoque combina la selección de elementos por ID (`withId`) y la ejecución de acciones (`perform(click())`, `perform(typeText(...))`), que son los conceptos fundamentales explicados en el contexto.",39.87,VECTOR,True,False,True
¿Cómo se tiene que denominar el plan de calidad de un Sprint?,"Según el contexto proporcionado, el documento se denomina **informe de calidad**.

Este informe tiene como objetivo describir los problemas de calidad del producto y proporcionar un plan de acción para corregir las incidencias detectadas durante el Sprint.",21.57,VECTOR,True,True,True
¿Cuál es la versión exacta de la plataforma Jakarta EE que se utiliza en el curso?,"Según la información del contexto, la versión exacta de la plataforma que se utiliza en el curso es **Jakarta EE 9.1**.

Esta versión se menciona explícitamente en varias partes del texto:

*   En la **Bibliografía Básica**: ""Oracle and affiliates (2021): The Jakarta EE Tutorial (Release 9.1)"".
*   En la **Bibliografía complementaria**: ""Eclipse Foundation: Jakarta EE Platform 9.1 Specification"".
*   En el encabezado de una de las diapositivas: ""Jakarta EE 9.1 APIs"".",22.94,VECTOR,True,True,True
¿Qué puerto utiliza por defecto la consola de administración de Glassfish?,"Según la información proporcionada, el puerto que utiliza por defecto la consola de administración de Glassfish es el **4848**.

Puedes acceder a ella a través de la URL `localhost:4848` para comprobar que la instalación se ha realizado correctamente.",22.63,VECTOR,True,True,True
¿Qué anotación se utiliza en JPA para indicar que un atributo no debe ser persistido en la base de datos?,"Según la información proporcionada, la anotación que se utiliza en JPA para indicar que un atributo no debe ser persistido en la base de datos es **`@Transient`**.

El contexto especifica que el estado persistente de una entidad lo forman todos sus atributos/propiedades, **excepto aquellos que están anotados con `@Transient`**.",22.85,VECTOR,True,True,True
¿Cuál es el nombre del plugin de Maven recomendado para desplegar aplicaciones en Glassfish?,"Basándome en el contexto proporcionado, no puedo responder a la pregunta. El texto de contexto consiste en una serie de números y símbolos sin un significado aparente en relación con la Ingeniería de Software, Maven o Glassfish.",29.88,VECTOR,True,True,True
¿Dónde puedo encontrar las reglas a aplicar para la nomenclatura de las clases de prueba?,"Según la información del contexto, las reglas para la nomenclatura de las clases de prueba se encuentran en la sección **""Nomenclatura y organización de las clases de prueba""**.

Las reglas son las siguientes:

### Pruebas Unitarias:
*   **Denominación:** Se nombran como `<NombreClase>Test.java`, donde `<NombreClase>` es el nombre de la clase que se está probando.
*   **Ubicación:** Se almacenan en el directorio `test`.
*   **Paquete:** Se definen en un paquete con el mismo nombre que el paquete donde se encuentra la clase bajo prueba.

### Pruebas de Integración:
*   **Denominación:** Se nombran como `<NombreClase>ITest.java`, donde `<NombreClase>` es el nombre de la clase principal que se está probando.
*   **Ubicación:** También se almacenan en el directorio `test`.
*   **Paquete:** Se definen en un paquete con el mismo nombre que el paquete donde se encuentra la clase principal bajo prueba.",28.88,VECTOR,True,True,True
Explicame la relevancia del testInstrumentationRunner en la configuración de pruebas para Android y cómo coordina la ejecución en dispositivos reales.,"Basándome en el contexto proporcionado, aquí te explico la relevancia del `testInstrumentationRunner` en la configuración de pruebas para Android:

El `testInstrumentationRunner` es un componente fundamental para ejecutar pruebas que necesitan interactuar con el framework de Android y, por lo tanto, deben ejecutarse en un dispositivo real o emulado.

Su relevancia y función se pueden resumir en los siguientes puntos extraídos del contexto:

1.  **Es el Orquestador de Pruebas en Dispositivos:** El `testInstrumentationRunner` es el punto de entrada que se encarga de cargar y ejecutar tu código de prueba junto con el código de tu aplicación en un dispositivo o emulador. Coordina el ciclo de vida de la aplicación y de las pruebas para que puedan interactuar entre sí.

2.  **Asociado a Pruebas de Interfaz Gráfica (`androidTest`):** El contexto indica claramente que las pruebas de interfaz gráfica (como las que usan Espresso) se ubican en el directorio `androidTest`. Estas pruebas **""requieren dispositivos reales o emulados para su ejecución""**.

3.  **Configuración Esencial para Espresso:** La configuración básica para el framework de pruebas de UI Espresso incluye explícitamente añadir la siguiente línea en el fichero `build.gradle` dentro de `android.defaultConfig`:
    ```groovy
    testInstrumentationRunner ""androidx.test.runner.AndroidJUnitRunner""
    ```
    Esto establece que `AndroidJUnitRunner` será el responsable de ejecutar estas pruebas instrumentadas.

En resumen, cuando configuras el `testInstrumentationRunner`, le estás diciendo al sistema de compilación de Android qué herramienta debe usar para instalar y ejecutar tus pruebas del directorio `androidTest` en un dispositivo. Sin esta configuración, el sistema no sabría cómo lanzar y gestionar las pruebas que dependen del entorno completo de Android, como las pruebas de interfaz de usuario.",39.0,VECTOR,True,False,True
¿Puede haber valores anómalos en las fechas proporcionadas dentro del servicio de datos?,"Sí, según el contexto proporcionado, se contempla la posibilidad de que existan valores anómalos en las fechas.

Específicamente, el punto 9 del contexto indica:

""Existen criterios de confirmación consensuados con el *Product Owner* para tratar situaciones que puedan considerarse anómalas, como **la ausencia de fecha en ciertos elementos de una colección a la hora de ordenar dicha colección por fecha**.""

Esto confirma que el sistema está diseñado para prever y gestionar anomalías relacionadas con los datos de fecha.",30.83,VECTOR,True,True,True
¿Hay que tratar casos de valores anómalos en las fechas para los criterios de confirmación?,Ocurrió un error técnico al consultar el grafo de conocimiento.,21.2,GRAPH,False,False,False
