question,response,time_sec,route,relevant,supported,useful
¿Cuántas horas debe trabajar cada estudiante por sprint?,"Según la información proporcionada, cada estudiante debe dedicar **36 horas de trabajo efectivo por sprint**.

Este cálculo se obtiene de la siguiente manera:
1.  La carga de trabajo total por sprint es de **40 horas** por persona (20 horas por semana durante dos semanas).
2.  A estas 40 horas se le descuentan **4 horas** dedicadas a las reuniones de Scrum (Sprint Planning, Product Backlog Refinement, Sprint Review y Sprint Retrospective).
3.  El resultado final es de **36 horas** de trabajo efectivo para la realización del proyecto.",19.05,VECTOR,False,False,False
¿Cómo debo nombrar al apk?,"Basándome en el contexto proporcionado, no hay información sobre cómo se debe nombrar el archivo APK.

La documentación describe los casos de uso de una aplicación de seguros, conceptos de persistencia de datos con `EntityManager` y ejemplos de actores en un sistema, pero no menciona ninguna convención de nomenclatura para el archivo de la aplicación.",15.56,VECTOR,False,False,False
¿Cuál es la diferencia entre requisitos funcionales y no funcionales? Explícamelo con una tabla comparativa.,"Hola, soy TutorIS, tu asistente experto en Ingeniería de Software.

Basándome en la información proporcionada, aquí te explico la diferencia entre requisitos funcionales y no funcionales a través de una tabla comparativa.

La diferencia fundamental, según el contexto, es que los **requisitos funcionales** describen **lo que el sistema debe hacer** (sus funciones y tareas), mientras que los **requisitos no funcionales** describen **cómo debe hacerlo** (sus cualidades, restricciones y características de rendimiento).

Para ilustrar mejor estas diferencias, aquí tienes una tabla comparativa basada en la información del contexto:

| Característica | Requisitos Funcionales | Requisitos No Funcionales |
| :--- | :--- | :--- |
| **Definición Principal** | Describen **lo que el sistema debe hacer**. Se centran en las funciones, tareas específicas y objetivos del usuario. | Describen las **cualidades y restricciones** del sistema. Se centran en cómo el sistema realiza sus funciones. |
| **Enfoque** | El ""qué"". Se relacionan con la **Adecuación Funcional**: completitud, corrección y pertinencia de las funciones para cumplir las tareas. | El ""cómo"". Se relacionan con la calidad del sistema, como el rendimiento, la fiabilidad y la capacidad de recuperación. |
| **Ejemplos** | - **Completitud Funcional:** El sistema debe cubrir todas las tareas especificadas, como ""permitir al usuario registrarse"" o ""generar un",30.93,VECTOR,False,False,False
¿Cómo se organizan las pruebas unitarias?,"Hola, con gusto te ayudo a resolver tu duda.

Analizando la información de las asignaturas, la organización de las pruebas unitarias se puede entender desde dos perspectivas: su ubicación física en el proyecto y su planificación estratégica.

1.  **Ubicación en el Proyecto (Organización Física):**
    *   En los proyectos de Android, tanto las pruebas unitarias como las de integración se almacenan y organizan dentro de un directorio específico conocido como **Directorio Test**. Esta es la ubicación estándar para todas las clases de prueba, lo que permite separarlas claramente del código de la aplicación.

2.  **Planificación y Estrategia (Organización Lógica):**
    *   La estrategia para llevar a cabo las pruebas unitarias se define en un documento llamado **Plan de Pruebas**. Este artefacto es fundamental, ya que describe el alcance, los objetivos y los recursos destinados a las pruebas.
    *   Específicamente para las pruebas unitarias, el plan detalla qué componentes y métodos de la aplicación serán sometidos a prueba, definiendo los casos de uso concretos a verificar.
    *   Además, como se menciona en la documentación de `proyecto_Integrado` (pruebas.md), se utilizan frameworks como **Robolectric** para facilitar la ejecución de estas pruebas unitarias directamente en el entorno de desarrollo, sin necesidad de un emulador, especialmente cuando interactúan con librerías de Android.

En resumen, las pruebas unitarias se organizan físicamente en el **Directorio Test** del proyecto y su ejecución se planifica y documenta estratégicamente en el **Plan de Pruebas**.",26.73,GRAPH,False,False,False
¿Cómo se puede probar un método de una clase que ejecuta en su propio thread sin usar Thread.Sleep?,"Hola, entiendo perfectamente tu pregunta. Probar código concurrente o asíncrono es un desafío común y usar `Thread.Sleep()` es una práctica poco fiable que debe evitarse.

Analizando la información de los cursos, el enfoque recomendado para las pruebas se centra en la **Prueba Unitaria** y la **Verificación de Comportamiento** utilizando frameworks como **JUnit** y **Mockito**. Aunque los documentos no describen un caso exacto para probar hilos (`Process Thread`), podemos aplicar los conceptos que sí mencionan para resolver tu problema de una manera robusta.

La estrategia consiste en utilizar **Objetos Mock** para verificar las interacciones que el método en el nuevo hilo realiza sobre sus dependencias, en lugar de esperar un tiempo fijo y comprobar un resultado final.

Aquí te explico el enfoque paso a paso:

1.  **Aislar la clase:** En tu prueba unitaria, identifica las dependencias de la clase cuyo método quieres probar. Estas dependencias son las que el método dentro del hilo utilizará.
2.  **Crear Mocks:** Utiliza **Mockito** para crear objetos simulados (`Objeto Mock`) de esas dependencias.
3.  **Ejecutar el método:** Llama al método que inicia el hilo. Este hilo, al ejecutarse, interactuará con los objetos mock que has creado, no con los reales.
4.  **Verificar con Timeout:** Aquí está la clave para no usar `Thread.Sleep()`. Mockito ofrece funcionalidades de verificación que pueden esperar durante un tiempo máximo a que ocurra una interacción.

Aunque la documentación proporcionada no detalla este método específico, una funcionalidad estándar de **Mockito** que soluciona tu problema es `timeout()`. Lo usarías de la siguiente manera:

```java
// Ejemplo conceptual
import static org.mockito.Mockito.*;

// 1. y 2. Crear el mock de la dependencia
MiDependencia mockDependencia = mock(MiDependencia.class);
ClaseBajoPrueba sut = new ClaseBajoPrueba(mockDependencia);

// 3. Ejecutar el método que corre en otro hilo
sut.metodoAsincrono();

// 4. Verificar la interacción con un timeout de, por ejemplo, 1 segundo (1000 ms)
// La prueba esperará HASTA 1 segundo a que se llame a 'metodoDeLaDependencia()'.
// Si la llamada ocurre antes, la prueba continúa inmediatamente.
// Si no ocurre en ese tiempo, la prueba falla.
verify(mockDependencia, timeout(1000)).metodoDeLaDependencia();
```

Este enfoque, basado en la **Verificación de Comportamiento** que promueve **Mockito**, es superior a `Thread.Sleep()` porque:
*   **Es más rápido:** No espera un tiempo fijo si la interacción ocurre antes del timeout.
*   **Es más fiable:** Evita fallos aleatorios (pruebas ""flaky"") que ocurren cuando el hilo tarda más de lo esperado en un `Sleep` fijo.
*   **Verifica comportamiento, no estado:** Se centra en asegurar que la colaboración entre objetos es correcta, lo cual es un principio fundamental de las pruebas unitarias.

En resumen, la solución es combinar el uso de **Objetos Mock** con las capacidades de verificación asíncrona de **Mockito** para crear pruebas deterministas y eficientes para tu código concurrente.",31.34,GRAPH,False,False,False
"En pruebas con Espresso ¿cómo se puede acceder a un SearchView que se encuentra dentro de un Toolbar, de los que usan el icono de lupa?","Hola, soy TutorIS, tu asistente experto en Ingeniería de Software.

Basándome en el contexto proporcionado, no hay una instrucción específica sobre cómo acceder a un `SearchView` que se encuentra dentro de un `Toolbar`. La información disponible se centra en elementos como `listView`, `spinner`, menús de opciones y la gestión de `intents`.

Sin embargo, como experto en la materia, puedo darte una guía general sobre cómo se suele abordar este problema en Espresso, siguiendo los principios que se observan en el contexto (como el uso de `onView` y `withId`).

Generalmente, el proceso consta de dos pasos:

1.  **Hacer clic en el icono de la lupa** para expandir el `SearchView`. Este icono es un elemento del menú y, por lo tanto, tiene un ID.
2.  **Escribir en el campo de texto** que aparece una vez que el `SearchView` está activo.

El código para realizar estas acciones sería similar a este:

```java
// 1. Haz clic en el icono de la lupa (debes reemplazar 'R.id.action_search' 
//    con el ID real de tu item de menú).
onView(withId(R.id.action_search)).perform(click());

// 2. Escribe el texto en el SearchView. El ID del campo de texto dentro de un 
//    SearchView de AppCompat suele ser 'search_src_text'.
onView(isAssignableFrom(EditText.class)).perform(typeText(""texto a buscar""), pressKey(KeyEvent.KEYCODE_ENTER));
```

**Puntos importantes:**

*   Debes asegurarte de que el ID `R.id.action_search` corresponde al que has definido en tu fichero de menú XML para el ítem de búsqueda.
*   En lugar de buscar por un ID específico para el campo de texto (que a veces puede ser complicado de encontrar), una estrategia robusta es buscar una vista que sea de la clase `EditText` (`isAssignableFrom(EditText.class)`), ya que normalmente será la única visible en ese momento.
*   `typeText(...)` escribe el texto deseado y `pressKey(KeyEvent.KEYCODE_ENTER)` simula la pulsación de la tecla ""Enter"" para iniciar la búsqueda.",27.95,VECTOR,False,False,False
¿Cómo se tiene que denominar el plan de calidad de un Sprint?,"Según el contexto proporcionado, el documento que describe los problemas de calidad y proporciona un plan de acción se denomina **informe de calidad**.",10.86,VECTOR,False,False,False
¿Cuál es la versión exacta de la plataforma Jakarta EE que se utiliza en el curso?,"Basándote en la información del contexto, la versión exacta de la plataforma que se utiliza es **Jakarta EE Platform 9.1**.

Esta información se encuentra en la sección de ""Bibliografía complementaria"", donde se menciona explícitamente: ""Eclipse Foundation: Jakarta EE Platform 9.1 Specification"".",14.03,VECTOR,False,False,False
¿Qué puerto utiliza por defecto la consola de administración de Glassfish?,"Según la información proporcionada, el puerto que utiliza por defecto la consola de administración de Glassfish es el **4848**.

Puedes acceder a ella a través de la dirección `localhost:4848`.",12.8,VECTOR,False,False,False
¿Qué anotación se utiliza en JPA para indicar que un atributo no debe ser persistido en la base de datos?,"Según la información proporcionada, la anotación que se utiliza en JPA para indicar que un atributo no debe ser persistido en la base de datos es **`@Transient`**.

El contexto especifica que ""El estado persistente de la entidad lo forman los valores de todos sus atributos/propiedades excepto aquellos anotados con `@Transient`"".

Aquí tienes un ejemplo extraído del contexto:

```java
import jakarta.persistence.Entity;

@Entity
public class Usuario implements Serializable {
    @Id
    private String nombre;
    
    @Transient
    private String email; // Este atributo no se guardará en la base de datos
    
    // ... resto de la clase
}
```",16.49,VECTOR,False,False,False
¿Cuál es el nombre del plugin de Maven recomendado para desplegar aplicaciones en Glassfish?,"Basándome en el contexto proporcionado, no es posible determinar el nombre del plugin de Maven recomendado para desplegar aplicaciones en Glassfish.

La información de contexto consiste en una serie de números y símbolos codificados que no contienen texto legible sobre plugins de Maven, Glassfish o cualquier otro tema de ingeniería de software.",18.94,VECTOR,False,False,False
¿Dónde puedo encontrar las reglas a aplicar para la nomenclatura de las clases de prueba?,"Según la información proporcionada, las reglas para la nomenclatura de las clases de prueba se encuentran en la sección **""Nomenclatura y organización de las clases de prueba""**.

Las reglas son las siguientes:

**Para pruebas unitarias:**

*   Se denominan `<NombreClase>Test.java`, donde `<NombreClase>` es el nombre de la clase que se está probando.
*   Se almacenan en el directorio `test`.
*   Se definen en un paquete con el mismo nombre que el paquete de la clase bajo prueba.

**Para pruebas de integración:**

*   Se denominan `<NombreClase>ITest.java`, donde `<NombreClase>` es el nombre de la clase principal bajo prueba.
*   Se almacenan en el directorio `test`.
*   Se definen en un paquete con el mismo nombre que el paquete de la clase principal bajo prueba.",15.36,VECTOR,False,False,False
Explicame la relevancia del testInstrumentationRunner en la configuración de pruebas para Android y cómo coordina la ejecución en dispositivos reales.,"Analizando la información proporcionada sobre el testing en aplicaciones Android, te explico la relevancia del `testInstrumentationRunner`.

El `testInstrumentationRunner` es un componente clave en la configuración de pruebas para Android, ya que actúa como el punto de entrada y el orquestador para ejecutar las pruebas que necesitan un entorno de dispositivo real o emulado. Estas se conocen como pruebas instrumentadas.

Su relevancia y funcionamiento se pueden desglosar de la siguiente manera:

1.  **Ejecutor de Pruebas Instrumentadas:** La información menciona la clase `Androidx.Test.Runner.Androidjunitrunner` como el ""runner"" de Android para ejecutar pruebas instrumentadas. Esto significa que cuando lanzas este tipo de pruebas, es esta clase la que se encarga de cargar tu código de test y tu aplicación en un dispositivo y coordinar la ejecución.

2.  **Coordinación con Pruebas de Interfaz Gráfica:** Como se indica en los materiales, las **Pruebas de Interfaz Gráfica (Test Interfaz Grafica)**, que a menudo se escriben con frameworks como **Espresso**, se localizan en el **Directorio Androidtest**. La razón por la que están en este directorio específico es porque requieren un dispositivo para poder interactuar con la UI de la aplicación. El `testInstrumentationRunner` es el mecanismo que hace posible esta ejecución en el dispositivo.

3.  **Proceso de Ejecución en un Dispositivo:** Cuando ejecutas los tests del directorio `androidTest`, el `runner` realiza los siguientes pasos:
    *   Instala el APK de tu aplicación en el dispositivo conectado (real o emulado).
    *   Instala un APK de prueba por separado que contiene tu código de test.
    *   Inicia el proceso de la aplicación y el `runner` se ""adhiere"" a él.
    *   Ejecuta las pruebas una por una, simulando interacciones de usuario (clics, escritura, etc.) y verificando el estado de la UI, tal como lo harías con Espresso.
    *   Finalmente, recopila los resultados de las pruebas y los reporta al entorno de desarrollo (por ejemplo, Android Studio).

En resumen, el `testInstrumentationRunner` es el puente fundamental entre tu código de prueba y la aplicación ejecutándose en un entorno Android real. Sin él, no sería posible automatizar las **Pruebas de Interfaz Gráfica** o las **Pruebas de Integración (Test Integracion)** que dependen de las APIs del sistema operativo **Android**, ya que estas no pueden ejecutarse en una máquina virtual de Java estándar.

Esta información se deduce de las definiciones y relaciones conceptuales extraídas de los documentos del curso, como `ps-2324-semExpresso.pdf` y `compiled.txt`.",27.65,GRAPH,False,False,False
¿Puede haber valores anómalos en las fechas proporcionadas dentro del servicio de datos?,"Sí, es posible que existan valores anómalos en las fechas.

Según el contexto proporcionado, se contempla explícitamente esta posibilidad y se han definido procedimientos para manejarla. En concreto, el texto menciona:

*   **Existen criterios de confirmación consensuados con el *Product Owner*** para tratar situaciones que puedan considerarse anómalas, como **la ausencia de fecha en ciertos elementos de una colección** a la hora de ordenar dicha colección por fecha.

Esto indica que el sistema está preparado para encontrar y gestionar anomalías como fechas faltantes en los datos.",18.12,VECTOR,False,False,False
¿Hay que tratar casos de valores anómalos en las fechas para los criterios de confirmación?,"Lo siento, no estoy seguro de cómo clasificar tu pregunta. ¿Podrías reformularla?",18.53,UNKNOWN,False,False,False
